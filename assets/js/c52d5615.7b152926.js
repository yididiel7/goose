"use strict";(self.webpackChunkgoose=self.webpackChunkgoose||[]).push([[8882],{45369:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var i=n(12012),o=n(74848),r=n(28453);const a={title:"Securing the Model Context Protocol",description:"Building secure and capable AI integrations with Model Context Protocol (MCP) at Block.",authors:["alex"]},s=void 0,l={authorsImageUrls:[void 0]},c=[{value:"What is the Model Context Protocol (MCP)",id:"what-is-the-model-context-protocol-mcp",level:2},{value:"MCP Misconceptions",id:"mcp-misconceptions",level:2},{value:"How do we approach making it secure?",id:"how-do-we-approach-making-it-secure",level:2},{value:"Securing Agentic Communications to MCP Servers",id:"securing-agentic-communications-to-mcp-servers",level:3},{value:"Securing MCP Communications to Tooling/Servers",id:"securing-mcp-communications-to-toolingservers",level:3},{value:"Agent, Human and Device Identity",id:"agent-human-and-device-identity",level:3},{value:"Human in the loop for operational safety",id:"human-in-the-loop-for-operational-safety",level:3},{value:"Securing the MCP Supply Chain",id:"securing-the-mcp-supply-chain",level:3},{value:"Conclusion",id:"conclusion",level:2}];function h(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components},{Head:i}=t;return i||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Head",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"blog cover",src:n(76146).A+"",width:"1200",height:"630"})}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:(0,o.jsxs)(t.em,{children:[(0,o.jsx)(t.strong,{children:"Authors:"})," Alex Rosenzweig, Arihant Virulkar, Andrea Leoszko, Wes Ring, Mike Shema, F G, Alex Klyubin, Michael Rand, Zhen Lian, Angie Jones, Douwe Osinga, Mic Neale, Bradley Axen, Gelareh Taban"]})}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:'At Block, we\u2019ve been working hard to augment the capabilities of AI tooling by building "MCP Servers" which are designed to help make our Artificial Intelligence (AI) Agent codename goose more capable of interacting with the systems and tools we care about.'}),"\n",(0,o.jsx)(t.p,{children:"Block\u2019s Information Security (InfoSec) team has been heavily involved in this work and we wanted to capture our learnings in the space to help others. We expect there to be growing adoption and use cases for this including applying the technology in the security domain."}),"\n",(0,o.jsx)(t.h2,{id:"what-is-the-model-context-protocol-mcp",children:"What is the Model Context Protocol (MCP)"}),"\n",(0,o.jsxs)(t.p,{children:["Model Context Protocol (MCP) is a protocol ",(0,o.jsx)(t.a,{href:"https://docs.anthropic.com/en/docs/agents-and-tools/mcp",children:"developed by Anthropic"}),', with input from Block engineers, that makes it easier to build integrations for agents to connect and use other tooling. Put simply, if you want AI to connect to SaaS solutions (e.g. Github, Jira),  CLI tools (e.g. AWS CLI) or your own custom applications you can write an MCP server and "teach" it how to correctly interact.']}),"\n",(0,o.jsx)(t.p,{children:'This has huge advantages as we can create deterministic, well defined interfaces that reduce the amount of "experimentation/brute force" required for agents to perform helpful tasks.'}),"\n",(0,o.jsx)(t.p,{children:'A use case like "read this ticket from Jira and then clone the relevant github repo and implement the feature" is more likely to succeed if the agent doesn\u2019t have to work out how to interact with Jira, Github and the Git CLI.'}),"\n",(0,o.jsx)(t.p,{children:"This helps agents to spend time solving novel problems rather than burning tokens understanding well defined API specifications."}),"\n",(0,o.jsx)(t.p,{children:"The following is example code from an MCP tool that integrates with an Snowflake API."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-python",children:'@mcp.tool()\nasync def submit_feedback(\n    feedback: str\n) -> Dict[str, Union[str, int, List]]:\n    """Submit feedback to the Snowflake team.\n\n    Args:\n        feedback: Feedback message\n\n    Returns:\n        Dictionary containing feedback status\n    """\n    return snowflake_client.submit_feedback(\n        feedback_text=feedback\n    )\n'})}),"\n",(0,o.jsx)(t.h2,{id:"mcp-misconceptions",children:"MCP Misconceptions"}),"\n",(0,o.jsx)(t.p,{children:'There are some minor misconceptions around MCP, which is understandably exacerbated by some of the verbiage not accurately aligning with more analogous technologies. The biggest point of confusion is the terminology of "MCP Servers".'}),"\n",(0,o.jsx)(t.p,{children:'Upon initially reviewing MCP, I noticed multiple references to "MCP Servers," which led me to believe that integrating with them would require modifications to the application backend.'}),"\n",(0,o.jsx)(t.p,{children:'However, these "servers" act as a client layer (either locally or remotely) to help the agent proxy function calls to an existing service, tool, API or RPC in a deterministic manner.'}),"\n",(0,o.jsx)(t.p,{children:"When securing an MCP integration we need to think about two sets of communications:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"How does the agent talk to the MCP Server?"}),"\n",(0,o.jsx)(t.li,{children:"How does the MCP Server act as a client for the system it connects to?"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"We can model this by:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Treating the Agent as a non-deterministic client that can arbitrarily call tools provided by the MCP server. This is due to the fact that we don\u2019t know what prompts it will be provided."}),"\n",(0,o.jsx)(t.li,{children:"Treating the MCP Server as a Client Library for the utility/utilities it integrates into. The client type can vary (gRPC, REST, SOAP, CLI, etc.) but in practice, MCPs simply provide a codified way to execute an action."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"For the former, we can lean into existing practices, understand the scope of access and what risks they present if used inappropriately."}),"\n",(0,o.jsx)(t.p,{children:"For the latter, we can directly model it as a client for an external provider. This is a well understood pattern as client library generation is in no way new."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"MCP Workflow",src:n(92069).A+"",width:"1600",height:"705"})}),"\n",(0,o.jsx)(t.h2,{id:"how-do-we-approach-making-it-secure",children:"How do we approach making it secure?"}),"\n",(0,o.jsx)(t.p,{children:"Using this mental model we can break MCP security into a few components:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Secure the Agents communication to the MCP"}),"\n",(0,o.jsx)(t.li,{children:"Secure the MCPs connectivity to the tool/server"}),"\n",(0,o.jsx)(t.li,{children:"Secure the identity of the user and the agent when talking to servers"}),"\n",(0,o.jsx)(t.li,{children:"Secure the underlying host and supply chain"}),"\n"]}),"\n",(0,o.jsx)(t.h3,{id:"securing-agentic-communications-to-mcp-servers",children:"Securing Agentic Communications to MCP Servers"}),"\n",(0,o.jsx)(t.p,{children:'In the current operating model both the Agent and the MCP Server run on the "client side".'}),"\n",(0,o.jsx)(t.p,{children:"However, the majority of agentic tools are integrated with LLMs provided by third parties. This has implications for data privacy and security."}),"\n",(0,o.jsxs)(t.p,{children:["For example if you expose an MCP interface that returns confidential data like Social Security Numbers (",(0,o.jsx)(t.a,{href:"https://code.cash.app/dsl-framework",children:"what we at Block call DSL4 data"}),") then you run the risk of that data being exposed to the underlying LLM provider."]}),"\n",(0,o.jsx)(t.p,{children:'A mitigation here is allowing MCP implementation to specify an allowlist of LLM providers that it can be integrated with as a configuration option. Having utilities to "tell" agents that can integrate with multiple models which models are allowed to invoke a given tool is a powerful primitive.'}),"\n",(0,o.jsx)(t.p,{children:"Back to our SSN example, if we could specify that this tool can only be invoked by local LLM models and trust the Agent Client to enforce this we could prevent sensitive data from being transmitted to third party LLMs. As a further enhancement, being able to instruct agents not to share tool output with other MCPs would provide further control of dataflow."}),"\n",(0,o.jsx)(t.h3,{id:"securing-mcp-communications-to-toolingservers",children:"Securing MCP Communications to Tooling/Servers"}),"\n",(0,o.jsx)(t.p,{children:"This paradigm actually isn\u2019t new and we can lean into existing best practices for externally facing APIs."}),"\n",(0,o.jsx)(t.p,{children:"Specifically, if we build our server side APIs with secure-by-design patterns already available through vetted frameworks already in-mind then we are already in a strong position as the MCP Server only acts as a client for these externally facing APIs and utilities."}),"\n",(0,o.jsx)(t.p,{children:"The reason this paradigm isn\u2019t new is due to the fact that anyone can already interact with external APIs and tooling and likely will call the endpoints in unexpected ways."}),"\n",(0,o.jsx)(t.p,{children:"This comes from the fact that LLMs interpret information in a manner that is different to human users, the protocol isn\u2019t implicitly allowing for agents to perform actions that users couldn\u2019t but LLMs may decide to perform actions that users wouldn\u2019t choose."}),"\n",(0,o.jsxs)(t.p,{children:["Where this ",(0,o.jsx)(t.strong,{children:"paradigm does shift"})," is when integrating with tooling not previously designed to be communicated with by all manner of clients. For example if an API was previously designed to only be communicated with by a specific client or implementation (such as a mobile APIs or internal tooling) then adopting MCP may lead to unexpected failure modes or security concerns."]}),"\n",(0,o.jsx)(t.p,{children:"This area is likely where Security Practitioners will need to concentrate further time and effort to limit integration scope to avoid damages in the event of a security attack against the underlying LLM or planning logic."}),"\n",(0,o.jsx)(t.h3,{id:"agent-human-and-device-identity",children:"Agent, Human and Device Identity"}),"\n",(0,o.jsx)(t.p,{children:"In our traditional model of Authentication (AuthN) and Authorization (AuthZ) it\u2019s common to tie an identity to a single point of abstraction such as a person or a business."}),"\n",(0,o.jsx)(t.p,{children:"This field has organically been evolving towards pairing a services identity user identity abstraction with identification of client devices such as browsers and mobile phones. This is done to help reduce the prevalence of attacks caused by automation and inauthentic traffic such as account takeover attacks (ATO)."}),"\n",(0,o.jsx)(t.p,{children:"With the evolution of Agents performing actions on behalf of users we will need to evolve to be able to determine the combination of:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"The primary identity abstraction"}),"\n",(0,o.jsx)(t.li,{children:"The agent\u2019s identity"}),"\n",(0,o.jsx)(t.li,{children:"The device/location the agent is running from"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Having consistent mechanisms for identifying usage in this manner allows companies to protect users from integrations with malicious agents and protect their platforms from attacks by unwanted agentic tooling."}),"\n",(0,o.jsxs)(t.p,{children:["The model context protocol itself has a ",(0,o.jsx)(t.a,{href:"https://spec.modelcontextprotocol.io/specification/2025-03-26/basic/authorization/",children:"specification for OAuth"})," that at the time of writing was a draft, but has since been released here."]}),"\n",(0,o.jsx)(t.p,{children:"This flow considers the following steps:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"Client/Agent initiates standard OAuth flow with MCP server"}),"\n",(0,o.jsx)(t.li,{children:"MCP server redirects user to third-party authorization server"}),"\n",(0,o.jsx)(t.li,{children:"User authorizes with third-party server"}),"\n",(0,o.jsx)(t.li,{children:"Third-party server redirects back to MCP server with authorization code"}),"\n",(0,o.jsx)(t.li,{children:"MCP server exchanges code for third-party access token"}),"\n",(0,o.jsx)(t.li,{children:"MCP server generates its own access token bound to the third-party session"}),"\n",(0,o.jsx)(t.li,{children:"MCP server completes original OAuth flow with Client/Agent"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"This is aligned with existing best practices but requires the MCPs themselves to have browser integrations/orchestration for OAuth to ensure they are able to redirect users effectively."}),"\n",(0,o.jsx)(t.p,{children:"A future enhancement we\u2019d love to see is requiring the agents to implement browser orchestration to provide an OAuth interface that MCPs themselves can integrate against and leverage. We believe this change would likely help standardise implementations and allow for protocol expansion to identify the agents and client alongside the user."}),"\n",(0,o.jsx)(t.p,{children:"Having individual MCP implementations implement OAuth themselves is likely to lead to long term security and maintenance issues due to misimplementation or delays adopting future protocol enhancements."}),"\n",(0,o.jsx)(t.h3,{id:"human-in-the-loop-for-operational-safety",children:"Human in the loop for operational safety"}),"\n",(0,o.jsx)(t.p,{children:"At a certain point we may build enough trust in our agents to allow them to perform more dangerous operations. For these kinds of use cases we can likely lean on known good practices for change management."}),"\n",(0,o.jsx)(t.p,{children:"Specifically, building server side solutions to alert the user to the expected changes and the agent performing them and seeking consent will likely be a critical primitive for APIs of the future. The goal of this would be to ultimately keep irreversible or hard to reverse actions gated behind human interaction or approval."}),"\n",(0,o.jsx)(t.p,{children:"For example, for an agent tasked with writing IaC, this could be as simple as requesting a human approver before applying/deploying the IaC."}),"\n",(0,o.jsx)(t.p,{children:"In client side agents this would improve data integrity in the event the underlying LLM hallucinated or was tampered with externally through malicious MCP or data sources."}),"\n",(0,o.jsxs)(t.p,{children:["In the latest release of the protocol, an enhancement we love is being able to ",(0,o.jsx)(t.a,{href:"https://github.com/modelcontextprotocol/specification/blob/9236eb1cbfa02c17ab45c83a7bdbe55c450070be/schema/2025-03-26/schema.ts#L730",children:"annotate a tool"}),' to indicate to clients that tool actions are "readOnly" or "destructive". Using this to decide when to require a secondary approval from the user before performing a given action provides significantly better protections for users.']}),"\n",(0,o.jsxs)(t.p,{children:["While we encourage an LLM based processing step to check for potentially malicious commands, ",(0,o.jsx)(t.strong,{children:"having a deterministic aspect to higher risk commands in tandem ensures good access control is a more accurate way to provide protections"}),"."]}),"\n",(0,o.jsx)(t.h3,{id:"securing-the-mcp-supply-chain",children:"Securing the MCP Supply Chain"}),"\n",(0,o.jsx)(t.p,{children:"At this stage the majority of MCPs are being installed and run client side via commands like docker, uvx, pipx and npx. In practice this means when users install MCP based extensions they are providing arbitrary code execution privileges to the MCP Server."}),"\n",(0,o.jsx)(t.p,{children:"In practice this presents a well documented and understood supply chain problem. How can we reduce risk associated with using third party code. The good news is that the same techniques still work including:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"Only install MCPs from trusted sources and are well maintained"}),"\n",(0,o.jsx)(t.li,{children:"Implement integrity checks and/or signing of artifacts where possible to ensure you\u2019re executing the expected code"}),"\n",(0,o.jsx)(t.li,{children:"Implement allow lists on enterprise agents to ensure users only use pre-validated MCPs"}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(t.p,{children:"Much like agents are paving the way to allow LLMs to have more real-world utility MCP and similar protocols will continue to grow in adoption."}),"\n",(0,o.jsx)(t.p,{children:"We believe that by contributing to open source projects early, sharing our learnings publicly, and building our own solutions that leverage MCP, Block can maintain security best practices from the deterministic world while continuing to evolve them with newer technologies."}),"\n",(0,o.jsx)(t.p,{children:"We\u2019re excited to work on making this protocol more secure for users and developers alike and are looking forward to sharing how we\u2019ve used MCP for our own Security use-cases in the future."}),"\n",(0,o.jsxs)(i,{children:[(0,o.jsx)("meta",{property:"og:title",content:"Securing the Model Context Protocol"}),(0,o.jsx)("meta",{property:"og:type",content:"article"}),(0,o.jsx)("meta",{property:"og:url",content:"https://block.github.io/goose/blog/2025/03/31/securing-mcp"}),(0,o.jsx)("meta",{property:"og:description",content:"Building secure and capable AI integrations with Model Context Protocol (MCP) at Block."}),(0,o.jsx)("meta",{property:"og:image",content:"http://block.github.io/goose/assets/images/securing-mcp-5e475e91c0e621afa33e30b3d89ef065.png"}),(0,o.jsx)("meta",{name:"twitter:card",content:"summary_large_image"}),(0,o.jsx)("meta",{property:"twitter:domain",content:"block.github.io/goose"}),(0,o.jsx)("meta",{name:"twitter:title",content:"Securing the Model Context Protocol"}),(0,o.jsx)("meta",{name:"twitter:description",content:"Building secure and capable AI integrations with Model Context Protocol (MCP) at Block."}),(0,o.jsx)("meta",{name:"twitter:image",content:"http://block.github.io/goose/assets/images/securing-mcp-5e475e91c0e621afa33e30b3d89ef065.png"})]})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},92069:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/mcp-workflow-9ef765371217ef59184cfddbbede89a4.png"},76146:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/securing-mcp-5e475e91c0e621afa33e30b3d89ef065.png"},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>s});var i=n(96540);const o={},r=i.createContext(o);function a(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(r.Provider,{value:t},e.children)}},12012:e=>{e.exports=JSON.parse('{"permalink":"/goose/blog/2025/03/31/securing-mcp","source":"@site/blog/2025-03-31-securing-mcp/index.md","title":"Securing the Model Context Protocol","description":"Building secure and capable AI integrations with Model Context Protocol (MCP) at Block.","date":"2025-03-31T00:00:00.000Z","tags":[],"readingTime":9.875,"hasTruncateMarker":true,"authors":[{"name":"Alex Rosenzweig","title":"Staff Security Engineer","page":{"permalink":"/goose/blog/authors/alex"},"socials":{"linkedin":"https://www.linkedin.com/in/alex-rosenzweig/","github":"https://github.com/shellz-n-stuff"},"imageURL":"https://media.licdn.com/dms/image/v2/C5103AQGrOYDDHn8z6g/profile-displayphoto-shrink_400_400/profile-displayphoto-shrink_400_400/0/1520985744775?e=1749081600&v=beta&t=krNAyF8rFRnInDfEZcO2TlLOHXWKMzt-fJdkgHVfFNs","key":"alex"}],"frontMatter":{"title":"Securing the Model Context Protocol","description":"Building secure and capable AI integrations with Model Context Protocol (MCP) at Block.","authors":["alex"]},"unlisted":false,"prevItem":{"title":"Community-Inspired Benchmarking: The Goose Vibe Check","permalink":"/goose/blog/2025/03/31/goose-benchmark"},"nextItem":{"title":"Vibe Coding with Goose and the Speech MCP","permalink":"/goose/blog/2025/03/28/vibe-coding-with-goose"}}')}}]);